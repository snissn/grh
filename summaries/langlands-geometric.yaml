a2a_doc:
  meta:
    title_long: "Geometric Langlands via Fixedâ€“Heat Positivity â€” Part IV: Geometric Completion and Linkage to the GRH Suite"
    title_short: "GL via Fixedâ€“Heat, Part IV"
    authors: ["Michael Seiler"]
    venue: "preprint (unrefereed)"
    year: 2025
    version: "Part IV"
    url: UNKNOWN
    area: "geometric Langlands; automorphic forms; explicit formula"
    normalization: "Tamagawa measures; Satake; MaaÃŸâ€“Selberg ledger matched to GLâ€“EF"
    primary_objects:
      - {name: X, type: "curve over ð”½_q", role: "base of bundles and Frobenius fixed loci"}
      - {name: G, type: "reductive group (focus GL_m)", role: "structure group"}
      - {name: Bun_G, type: "Artin stack", role: "moduli of G-bundles; site of kernels"}
      - {name: T_Î¦, type: "trace/correspondence", role: "Grothendieckâ€“Lefschetz (GLâ€“EF) trace"}
      - {name: Î¦, type: "kernel/object in D^b_c or MHM", role: "admissible test"}
      - {name: ð”½rob, type: "Frobenius", role: "trace operator"}
      - {name: ð“—_Ï–, type: "Hecke kernel (twoâ€“coweight)", role: "halfâ€“shift generator"}
      - {name: â„‹, type: "operator", role: "perverse halfâ€“shift"}
      - {name: ð•‹_Î½, type: "idempotent", role: "Î½â€“projector to oddâ€“energy"}
      - {name: ð”…, type: "budget vector", role: "ledger of error controls"}
      - {name: M_x,E_x, type: "contributions", role: "main/error local terms at xâˆˆ|X|"}
    normalization_sheet:
      finite_places: "Geometric Satake parameters; Tamagawa measure on G(ð”„_F) with vol(K_v)=1; Euler factors via |X|; aligned with Part I Satake/measure. src: sec:normalization,thm:dictionary"
      arch_place: "N/A (function field); PV/scattering not used here. src: paper:general"
      dictionary_constants: "proportionality set to 1: Tr_GLâ€“EF(Î¦_geom)=EF(Î¦_an). src: thm:dictionary"
    identities_checked:
      - "GLâ€“EF: Tr(ð”½rob|T_Î¦)=âˆ‘_x (M_x(Î¦)âˆ’E_x(Î¦)). src: thm:GLEF,eq:GLEF"
      - "Linear EF: EF(T)=âˆ‘_x M_x(T)âˆ’âˆ‘_x E_x(T). src: thm:I-linearEF,eq:linearEF"
      - "Halfâ€“shift: EF(â„‹(T))=EF(T)+Î”(T), Î”â‰¥0. src: thm:III-halfshift,eq:III-half-id"
      - "Loewner: âŸ¨â„‹(T),â„‹(T)âŸ© âª° âŸ¨T,TâŸ© âª° Î³â‚€â€–Tâ€–Â². src: thm:III-halfshift,eq:III-loewner"
    asks: "If any constant differs from Part I/II/III or standard Tamagawa/Satake references, list precise values and justification."
  problem_and_claim:
    problem: "Give a quantitative, falsifiable GLâ€“EF on stacks with explicit main/error separation, an operator halfâ€“shift improving positivity, and a Î½â€“witness barrier linking geometric positivity to GRH-type inputs."
    core_claims:
      - {id: C1, name: "Filtered GLâ€“EF on stacks", status: proved, statement: "GLâ€“EF identity with M_x, E_xâ‰¥0 and absolute convergence.", src: "thm:GLEF"}
      - {id: C2, name: "Augmented EF budgets", status: proved, statement: "E_x(T) â‰¤ Î±_x B_bdry+Î²_x B_wild+Î³_x B_ss+Î´_x B_geom with absolute convergence.", src: "thm:III-AEF"}
      - {id: C3, name: "Halfâ€“shift positivity", status: proved, statement: "â„‹ improves Gram pairing (Loewner) and adds Î”â‰¥0 to EF.", src: "thm:III-halfshift"}
      - {id: C4, name: "Noâ€‘fakeâ€‘positivity", status: proved, statement: "Under Î½â€“projector, odd energy carries no genuine main mass; witness is annihilated under GRHâ€‘type inputs.", src: "thm:II-projector, thm:II-witness"}
      - {id: C5, name: "GLâ‚ specialization", status: proved, statement: "GLâ€“EF reduces to divisor sum minus bounded truncation errors.", src: "prop:GL1"}
      - {id: C6, name: "Hodge/Betti form", status: proved, statement: "Betti/Hodge GLâ€“EF with Hodge ledger and subadditivity.", src: "thm:betti-GLEF, thm:hodge-subadd, def:hledger"}
      - {id: C7, name: "Equivalence", status: proved, statement: "Analytic fixedâ€“heat suite â‡” geometric statements under standard hypotheses.", src: "thm:GLC"}
    route_map:
      - {id: R1, name: "Stacky GLâ€“EF", inputs: ["stack Lefschetz","cleanness","generation"], output: "C1", status: proved}
      - {id: R2, name: "Budgets from Parts Iâ€“III", inputs: ["A1(A1Norm)","A2(A2Dist)","A4(A4Pos)","R*"], output: "C2", status: imported}
      - {id: R3, name: "Twoâ€“coweight halfâ€“shift", inputs: ["Hecke conv","perverse trunc"], output: "C3", status: proved}
      - {id: R4, name: "Î½â€“witness/GRH link", inputs: ["Î½â€“projector","GRHâ€‘type"], output: "C4", status: conditional}
    asks: "Provide a short â€˜why nowâ€™ and the single minimal new ingredient per claim."
  notation:
    symbols:
      X: "smooth projective curve over ð”½_q"
      "|X|": "closed points of X"
      F: "ð”½_q(X)"
      G: "reductive group (mainly GL_m)"
      Bun_G: "stack of G-bundles on X"
      Î¦: "admissible kernel (sheaf/MHM)"
      T_Î¦: "correspondence/trace class"
      ð”½rob: "geometric Frobenius"
      EF: "explicit formula functional"
      M_x,E_x: "main/error local pieces"
      ð”…: "budget (B_bdry,B_wild,B_ss,B_geom)"
      â„‹: "perverse halfâ€“shift op."
      ð“—_Ï–: "twoâ€“coweight Hecke kernel"
      ð•‹_Î½: "Î½â€“projector (odd energy)"
      âŸ¨Â·,Â·âŸ©: "Gram pairing"
    equivalences:
      - "GLâ€“EF trace â†” analytic EF (dictionary constant 1). src: thm:dictionary"
      - "Hecke convolution â†” test action under Satake. src: sec:dictionary"
    asks: "List domains/codomains for each operator and hidden IDs like X=G/K on spherical side, and the precise spectral model."
  spaces_and_classes:
    classes:
      - {name: "Admissible window (â„“â€‘adic)", membership: "HN slices fixed; weights in [w_-,w_+]; properness/cleanness of p,q maps.", src: "def:admissible"}
      - {name: "Admissible (Hodge)", membership: "MHM with analogous weight/depth bounds; Hodge ledger defined.", src: "def:hledger"}
      - {name: "Slice frame ð’¯", membership: "finite family stable under window ops; Gramâ€‘positive.", src: "thm:I-sliceframe"}
    norms:
      - "Gram norm from slice frame; Loewner order for operators. src: thm:III-halfshift"
      - "Budgets ð”… subadditive/monotone under conv/trunc. src: def:ledger,prop:budget,prop:trunc"
    asks: "Give minimal in/out examples for each class and a counterexample violating one criterion."
  assumptions:
    list:
      - {id: A1Norm, statement: "Tamagawa/Satake normalization fixed; dictionary constant=1.", params: "none", proved_here: false, proof_src: "Part I", portability: "GL_m/Fq(X)"}
      - {id: A2Dist, statement: "Distortion Îµ(N)=1/N; Îº_X=1 in bounds.", params: "Nâ‰¥1", proved_here: false, proof_src: "Part I", portability: "depends on X"}
      - {id: A4Pos, statement: "Positivity reserve Î±_X(t)>0.", params: "tâˆˆ(0,tâ‚€]", proved_here: false, proof_src: "Part I", portability: "heat model dependent"}
      - {id: R*, statement: "Ramified damping bounds with prefactor C_{R*}(m,K).", params: "m,K,t", proved_here: false, proof_src: "Part I", portability: "ramification profile"}
      - {id: H.Gen, statement: "Window generated by Hecke eigensheaves on bounded HN window", params: "fixed HN window", proved_here: true, proof_src: "prop:generation", portability: "GL_m; expected broader"}
      - {id: H.Clean, statement: "Cleanness/purity; strict weight drop on boundary within bounded HN window", params: "weights [w_-,w_+]", proved_here: true, proof_src: "prop:cleanness", portability: "window and group dependent"}
    counterexamples_or_limits:
      - "Nonâ€‘minuscule coweights: exact halfâ€“shift fails; only inequality. src: prop:minuscule"
      - "Failure of cleanness can create spurious positive boundary mass."
    asks: "Clarify sharpness of H.Gen/H.Clean and portability to other G and windows."
  constructions_and_kernels:
    operators:
      - {name: "â„‹(Î¦)=^pÏ„^{â‰¤0}(Î¦*ð“—_Ï–)", property: "Î”â‰¥0; Loewner improvement; budget contraction câˆˆ(0,1].", src: "def:halfshift, thm:III-halfshift"}
      - {name: "ð•‹_Î½", property: "idempotent; splits even/odd energy; odd pairs trivially with main terms.", src: "thm:II-projector"}
    factorization: "Local term expansions over Fix(ð”½rob;c) stratified by HN; generic vs boundary/wild split. src: def:ME"
    compatibility_checklist:
      commute_pairwise: "Yes on bounded HN window; convolution and perverse truncation commute up to ledgerâ€‘absorbed errors."
      commute_pairwise_src: "sec:halfshift, thm:GLEF"
      weyl_invariance: "Hecke/spherical compatible by Satake."
      weyl_invariance_src: "sec:dictionary"
      bounded_on_H: "Yes via Loewner and Gram bounds."
      bounded_on_H_src: "thm:III-halfshift"
      unitary_equiv: "Modelâ€‘independence via Satake equivalence."
      unitary_equiv_src: "sec:dictionary"
    asks: "State the functional calculus used to justify â„‹ and where symbol/weight bounds enter the Loewner sandwich."
  explicit_formula_block:
    geometric_side: "Tr(ð”½rob|T_Î¦)=âˆ‘_{xâˆˆ|X|}(M_x(Î¦)âˆ’E_x(Î¦)) with M_x generic strata and E_x boundary/wild/SS/geom. src: thm:GLEF,def:ME"
    spectral_side: "Trace on admissible category; Î½â€‘projector splits even/odd; halfâ€“shift adds Î”â‰¥0. src: thm:II-projector,thm:III-halfshift"
    regularization: "weights/purity; properness on window; truncations monotone; absolute convergence of âˆ‘E_x. src: def:admissible,thm:III-AEF"
    weil_functional_GL1: "Ï_W(x)=k_t(x)=(1/(2Ï€))e^{-x^2/(8t)}T_{1/2}(x); ð’¬_GL1(Î¦)=âˆ«_0^âˆž Ï_W(x)Â·Ä_Î¦(x) dx; dictionary constant = 1."
    weil_functional_GL1_src: "app:density, eq:PVWeil-main"
    rho_W_density: "Ï_W(x)=(1/(2Ï€))e^{-x^2/(8t)}T_{1/2}(x) (imported from Parts Iâ€“II)."
    rho_W_density_src: "app:density"
    ramified_ledger:
      - {term: "boundary", when_present: "HN boundary", sign: "Eâ‰¥0", bound: "â‰¤Î±_X(t)Â·B_bdry (A4 reserve)", vanishing_cases: "no boundary in window"}
      - {term: "wild", when_present: "ramification", sign: "Eâ‰¥0", bound: "â‰¤C_{R*}Â·e^{-Î²(m)Â·t}Â·B_wild (conductor exponent Î±(m,K))", vanishing_cases: "unramified"}
      - {term: "singular_support", when_present: "SSâ‰ 0", sign: "Eâ‰¥0", bound: "â‰¤Îº_XÂ·B_ss with Îº_X=1 (A2Dist)", vanishing_cases: "SS=0"}
      - {term: "geom residual", when_present: "degenerate strata", sign: "Eâ‰¥0", bound: "â‰¤Îµ(N)Â·B_geom with Îµ(N)=1/N (A2Dist)", vanishing_cases: "generic only"}
    positivity_table:
      - {piece: "M_x after â„‹", status: "â‰¥0 (by Î” addâ€‘on and Gram)", cond: "post halfâ€“shift"}
      - {piece: "E_x", status: "â‰¥0", cond: "by construction"}
      - {piece: "Î”", status: "â‰¥0", cond: "twoâ€“coweight â„‹"}
    asks: "Confirm which terms are â‰¥0 under each admissible class (â„“â€‘adic vs Hodge)."
  main_results:
    items:
      - {id: T1, name: "GLâ€“EF on stacks", statement: "Filtered GLâ€“EF with M/E split and conv.", conditions: "H.Gen,H.Clean", dependencies: ["P1:Stackâ€‘Lefschetz","D1:Dictionary"], status: proved, src: "thm:GLEF"}
      - {id: T2, name: "Augmented EF budgets", statement: "E_x bounds in terms of ð”… with absolute conv.", conditions: "A1,A2,A4,R*", dependencies: ["I:linearEF"], status: proved(imported), src: "thm:III-AEF"}
      - {id: T3, name: "Halfâ€“shift Loewner", statement: "EF gain Î”â‰¥0; âŸ¨Â·,Â·âŸ© Loewner improvement; budget contraction.", conditions: "admissible window", dependencies: ["Hecke conv","perverse trunc"], status: proved, src: "thm:III-halfshift, def:halfshift"}
      - {id: T4, name: "Witness barrier", statement: "Odd energy has no genuine main mass; GRH annihilates fake positivity.", conditions: "GRHâ€‘type", dependencies: ["Î½â€“projector"], status: conditional, src: "thm:II-projector, thm:II-witness"}
      - {id: T5, name: "Hodge ledger subadditivity", statement: "B^H subadditive/monotone.", conditions: "MHM admissible", dependencies: ["Betti Satake"], status: proved, src: "thm:hodge-subadd"}
    asks: "Give invariantâ€‘theoretic oneâ€‘liners explaining each positivity."
  dependency_graph:
    nodes: ["A1Norm","A2Dist","A4Pos","R*","H.Gen","H.Clean","I:linearEF","I:slice","II:projector","II:witness","III:halfshift","III:AEF","D1:Dictionary","P1:Stackâ€‘Lefschetz","T1","T2","T3","T4","T5"]
    edges:
      - "H.Gen -> P1:Stackâ€‘Lefschetz"
      - "H.Clean -> P1:Stackâ€‘Lefschetz"
      - "P1:Stackâ€‘Lefschetz -> T1"
      - "D1:Dictionary -> T1"
      - "I:linearEF -> T2"
      - "A1Norm -> T2"
      - "A2Dist -> T2"
      - "A4Pos -> T2"
      - "R* -> T2"
      - "III:halfshift -> T3"
      - "II:projector -> T4"
      - "II:witness -> T4"
      - "Betti Satake -> T5"
    asks: "Mark optional branches/cycles if any."
  proof_skeletons:
    T1:
      steps: ["Stacky GLâ€“EF via Lefschetz on slices", "Split Fix loci into generic vs boundary", "Identify M_x,E_x symbolically", "Show absolute conv.", "Assemble sum over |X|"]
      fragile_step: "cleanness/purity on boundary strata"
      alt_route: "work in Betti/MHM then â„“â€‘adic comparison"
    T2:
      steps: ["Import EF linear split", "Define budgets ð”…", "Bound E_x by ð”… with Î±_x..Î´_x", "Sum bounds; show conv.", "Stability under conv/trunc"]
      fragile_step: "uniformity of constants (Î±_x..Î´_x)"
      alt_route: "optimize slice frame (prop:opt-slice)"
    T3:
      steps: ["Define â„‹ via 2â€“coweight conv + ^pÏ„^{â‰¤0}", "Compute EF difference Î”", "Gram calculus â‡’ Loewner", "Show budget contraction câ‰¤1"]
      fragile_step: "exactness outside minuscule windows"
      alt_route: "iterate small minuscule steps"
    T4:
      steps: ["Apply ð•‹_Î½ to split odd/even", "Pair with main terms â‡’ 0", "Invoke GRHâ€‘type witness", "Conclude fake positivity impossible"]
      fragile_step: "use of GRHâ€‘type input"
      alt_route: "conditional zeroâ€‘free region"
    asks: "Identify the single step likeliest to fail in higher rank."
  limits_and_continuity:
    t_down_0: "All uses of heat parameter t imported; constants Î±_X(t) explicit. src: sec:budgets"
    continuity: "Budgets subadditive/monotone; âˆ‘E_x converges absolutely and uniformly in window. src: thm:III-AEF,prop:budget,prop:trunc"
    constants_table:
      - {name: "Î±_X(t)", uniform_in_t: "on (0,tâ‚€]", depends_on: "X", origin: "A4Pos"}
      - {name: "Îµ(N)=1/N", uniform_in_t: "yes", depends_on: "N", origin: "A2Dist"}
      - {name: "Îº_X=1", uniform_in_t: "yes", depends_on: "X", origin: "A2Dist"}
      - {name: "C_{R*}", uniform_in_t: "yes", depends_on: "m,K", origin: "R*"}
      - {name: "c", uniform_in_t: "yes", depends_on: "window", origin: "III-halfshift"}
      - {name: "Î³â‚€", uniform_in_t: "yes", depends_on: "frame", origin: "III-halfshift"}
    asks: "Provide where constants blow up (e.g., near window edges)."
  checks_and_recipes:
    numerical_recipe: "Choose simple window; evaluate GLâ‚ identity on degreeâ€‘â‰¤D divisors; compare âˆ‘E_x to budget bounds."
    symbolic_recipe: "Verify eq:GLEF by stratifying Fix loci and matching terms with def:ME."
    pseudocode: |
      build_window(); Phi := kernel(window);
      M,E := local_terms(Phi); assert sum_x(M)-sum_x(E) == Tr(T_Phi);
      Phi2 := half_shift(Phi); check Loewner(Gram(Phi2),Gram(Phi));
    toy_numeric:
      alpha: "Î±=1"
      Xcap: "X=5"
      test: "Ä(x)=e^{-Î±x}Â·1_{(0,X]}"
      rho_W_integral: "(1/(2Ï€))Â·âˆ«_0^X e^{-Î± x} e^{-x^2/(8t)} T_{1/2}(x) dx"
      prime_terms: "For GLâ‚ over ð”½_q(X): âˆ‘_{deg(x)â‰¤5} Î¦(ð’ª_X(x)) symbolically; compare to Tr(T_Î¦)."
    asks: "Provide a canonical toy Î¦ that smokesâ€‘tests signs and constant â€˜1â€™ in the dictionary."
  scope_and_unconditionality:
    unconditional: ["Stacky GLâ€“EF identity under H.Gen/H.Clean", "Halfâ€“shift Loewner and budget contraction", "Hodge ledger subadditivity"]
    conditional: ["Witness annihilation relies on GRHâ€‘type inputs from Part II", "Quantitative constants rely on Parts Iâ€“III"]
    program_inputs:
      - {id: A1, formal_statement: "Normalization lock; dictionary constant 1.", current_status: "imported", needed_for: "T1,T2", candidates_for_proof: "Part I"}
      - {id: A2, formal_statement: "Îµ(N)=1/N; Îº_X=1.", current_status: "imported", needed_for: "T2", candidates_for_proof: "Part I"}
      - {id: A4, formal_statement: "Î±_X(t)>0.", current_status: "imported", needed_for: "T2", candidates_for_proof: "Part I"}
      - {id: R*, formal_statement: "Ramified damping inequality with exponents Î²(m), Î±(m,K) and constant C_{R*}", current_status: "imported", needed_for: "T2", candidates_for_proof: "Part I"}
    resolved_inputs:
      A1:
        normalization_lock:
          dictionary_constant: 1
          description: "Tamagawa/Satake (Godementâ€“Jacquet) measures matched to MaaÃŸâ€“Selberg (PV), with GLâ€“EF dictionary fixed to 1."
        citations:
          - "GL Part IV Â§4.2.1(3) â€“ dictionary constant fixed to 1. :contentReference[oaicite:4]{index=4}"
          - "Functoriality Â§3 â€˜Normalization Dictionaryâ€™. :contentReference[oaicite:5]{index=5}"
        status: "resolved"
      A2:
        epsilon_N: "1/N"
        kappa_X: 1
        description: "Constructive halfâ€‘shift + tightâ€‘frame Loewner sandwich; ray-regularization error Îµ(N)=1/N and Loewner distortion Îº_X=1."
        citations:
          - "Functoriality Lemma 4.1 & (4.4)â€“(4.5) and Remark 4.2 (Îµ(N), Îº_X). :contentReference[oaicite:6]{index=6}"
        status: "resolved"
      A4:
        alpha_X:
          definition: "inf_{uâ‰ 0} âŸ¨u, P_t uâŸ© / âŸ¨u, Î“_t uâŸ© on the spherical slice"
          guarantee: "Î±_X(t) > 0 on tâˆˆ[t_min, t_0] (prime-side positivity reserve propagated by Loewner sandwich)."
          numeric_floor_note: "Reserve derives from Rankinâ€“Selberg mass; usable floor from Î²(d_r) after heat normalization."
        citations:
          - "Functoriality Lemma 4.1 (Positivity reserve) & Remark 4.2. :contentReference[oaicite:7]{index=7}"
        status: "resolved"
      R*:
        damping_bound: "|W_ram^{(t)}(Î¦)| â‰¤ C_{R*}(m,K,t) (1+log Q_K(Ï€))^{Î±(m,K)} Q_K(Ï€)^{-Î²(m)} M_t(Î¦)"
        exponents:
          alpha_mK: "4 m [K:Q]"
          beta_m: "1/(4 m log 2)"
        citations:
          - "Functoriality Â§3 (R*) and (7.5)â€“(7.6) with explicit admissible exponents. :contentReference[oaicite:8]{index=8}"
        status: "resolved"
    asks: "What is the minimum viable theorem if A4 is weakened or R* partially available?"
  limitations:
    list: ["Functionâ€‘field context; numberâ€‘field archimedean not treated", "Requires fixed HN window and purity/cleanness", "Exact halfâ€“shift requires minuscule coweights", "Dependence on imported constants from Parts Iâ€“III"]
    asks: "Give counterexamples when cleanness or generation fails."
  projections:
    ideas: ["Port GLâ€“EF budgets to number fields with archimedean heat", "Extend beyond GL_m via refined Satake", "Automate budget verification for functorial transfers", "Iterate â„‹ to optimize Loewner bound and gram constants"]
    asks: "Prioritize milestones (GLâ‚‚ explicit cases, minuscule windows, numeric checks) and a verification plan with benchmarks."
